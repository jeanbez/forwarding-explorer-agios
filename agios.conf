library_options:
{
	#should we generate trace files during execution? 
	trace = false ;

	#should we trace predicted requests? (for debug purposes, this trace will not be useful for future executions)
	trace_predict = false ;

	#should we make a complete trace, with all scheduler's operations, such as waiting times? (for debug purposes)
	trace_full = false ;

	#should the prediction module read trace files? (if false, the Prediction Module is useless)
	predict_read_traces = true ;

	#should the prediction module try to predict aggregations? (requires predict_read_traces = true)
	predict_request_aggregation = false ;

	#should the prediction module create simplified traces with information (the metrics) it obtained from the real traces?
	predict_write_simplified_traces = true;

	#the tolerance for arrival times difference when checking if two predicted requests are the same (in %)
	prediction_time_error = 10

	#this parameter gives the frequency with which the prediction module will redo its predicted aggregations  (in number of requests that must be processed between refreshs). This is necessary because these predictions use a factor that represents the ability to overlap waiting times with processing of other requests. At initialization, this factor will be calculated from the provided trace files, but during execution it can be recalculated using measurements for this ability during the actual scheduling. If the parameter is set to -1, aggregations will not be recalculated during execution.  (in number of requests)
	prediction_recalculate_alpha_period = -1

	#prefix and sufix for trace files (with path). Their names must be trace_file_prefix+"."+number+"."+trace_file_sufix, with ordered numbers (no holes)
	trace_file_prefix = "/tmp/agios_tracefile"
	trace_file_sufix = "out"
	#prefix for simple trace files (with path). Their names will be prefix+"."+number+"."+trace_file_sufix
	simple_trace_prefix = "/tmp/agios_simpletracefile"

	#file (with path) with access times functions (generated by SeRRa - http://serratoool.bitbucket.org/). Used by aIOLi to quantum assignment and by the mechanism that automatically selects the best scheduling algorithm to use. If you are using a static algorithm which is not aIOLi, this does not matter, but you need to provide it anyway. In this case, you can use the one provided as example with the library source code 
	access_times_func_file = "/tmp/access_times.func"

	#default I/O scheduling algorithm to use (the one to be used if the previous value was set to false)
	#existing algorithms (case sensitive): "MLF", "aIOLi", "SJF", "TO", "TO-agg", "SRTF", "TW", "NOOP", "DYN_TREE" (case sensitive) 
	# SRTF uses information from trace files (don't use it if these are not available)
	# NOOP is the no operation scheduling algorithm, you should not observe performance improvements by using this one
	# DYN_TREE is a dynamic scheduling algorithm which selects the best (among MLF, AIOLI, SFJ, TO, TO-AGG, and NOOP) according to a decision tree. Use it only when using AGIOS to schedule requests to parallel file system' servers.
	default_algorithm = "MLF" ;

	# Only relevant if default_algorithm is a dynamic one. this parameter giver the frequency with which the automatic scheduling algorithm selection will recalculate the scheduling algorithm. This selection will be done using the access pattern from this period. If -1 is provided, then the selection will be done at the beginning of execution only (using information from traces). The next parameter gives the minimum number of requests which need to happen in this period for the selection to be done (otherwise we will wait another period before recalculating).  (in msec)
	select_algorithm_period = 100

	select_algorithm_min_reqnumber=4

	#if default_algorithm is a dynamic algorithm, you need to indicate which static algorithm to use at first (before automatically selecting the next one)
	starting_algorithm = "SJF" ;
};
user_info:
{
	#stripe size used by the library's users (in bytes). This is used for detecting the access pattern at a parallel file system server. Useless for other uses. 
	stripe_size = 32768 ;

	#maximum buffer size used for storing trace parts (in KB). Having a buffer avoids generating requests to the local file system, which interfere in performance. On the other hand, having a large buffer can affect performance and decrease available space for data buffer.
	max_trace_buffer_size = 32768 ;

};
